/* eslint-disable @typescript-eslint/no-explicit-any */
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

// Custom service worker with SKIP_WAITING handler
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';

// Properly type self as ServiceWorkerGlobalScope
declare const self: ServiceWorkerGlobalScope;

// Disable dev logs
self.__WB_DISABLE_DEV_LOGS = true;

// Handle SKIP_WAITING message - THIS IS CRITICAL FOR UPDATE FUNCTIONALITY
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[SW] Received SKIP_WAITING message, activating new version');
    self.skipWaiting().then(() => {
      // After skip waiting, notify all clients
      self.clients.matchAll().then(clients => {
        clients.forEach(client => {
          client.postMessage({
            type: 'SW_UPDATED',
            message: 'Service worker updated successfully'
          });
        });
      });
    });
  }
});

// Precache all the assets generated by next-pwa
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches
cleanupOutdatedCaches();

// Allow service worker to claim clients immediately
clientsClaim();

// Cache static resources (CSS, JS, images)
registerRoute(
  /^\/(_next\/static|static)\/.*/i,
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 64,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  }),
  'GET'
);

// API routes - Network first with cache fallback
registerRoute(
  /\/api\/.*/,
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  }),
  'GET'
);

// Dynamic pages - Network first with cache fallback
registerRoute(
  /^\/(en|ar|fr)\/(manager|admin)\/.*/,
  new NetworkFirst({
    cacheName: 'dynamic-pages',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
  'GET'
);

// Add offline fallback for navigation requests
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    networkTimeoutSeconds: 3,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
  'GET'
);

// Add offline fallback for all other requests
registerRoute(
  ({ request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'pages',
    networkTimeoutSeconds: 3,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
  'GET'
);

// Add comprehensive offline fallback handler
self.addEventListener('fetch', (event: any) => {
  const { request } = event;
  
  // Handle navigation requests (page loads)
  if (request.mode === 'navigate') {
    event.respondWith(
      fetch(request)
        .then(response => {
          // If we get a response, cache it and return it
          if (response.status === 200) {
            const responseClone = response.clone();
            caches.open('pages').then(cache => {
              cache.put(request, responseClone);
            });
          }
          return response;
        })
        .catch(() => {
          // If network fails, try to serve from cache first
          return caches.match(request)
            .then(cachedResponse => {
              if (cachedResponse) {
                return cachedResponse;
              }
              // If no cached version, serve offline page
              return caches.match('/offline.html');
            });
        })
    );
  }
  
  // Handle document requests (HTML pages)
  if (request.destination === 'document') {
    event.respondWith(
      fetch(request)
        .then(response => {
          // Cache successful responses
          if (response.status === 200) {
            const responseClone = response.clone();
            caches.open('pages').then(cache => {
              cache.put(request, responseClone);
            });
          }
          return response;
        })
        .catch(() => {
          // Try cache first, then offline page
          return caches.match(request)
            .then(cachedResponse => {
              if (cachedResponse) {
                return cachedResponse;
              }
              return caches.match('/offline.html');
            });
        })
    );
  }
});

// Log service worker lifecycle events
self.addEventListener('install', (event: any) => {
  console.log('[SW] Service worker installed');
  
  // Precache the offline page
  event.waitUntil(
    caches.open('offline-pages').then(cache => {
      return cache.add('/offline.html');
    })
  );
});

self.addEventListener('activate', (event :any) => {
  console.log('[SW] Service worker activated' , event);
});

// Export to make this a module
export { };

