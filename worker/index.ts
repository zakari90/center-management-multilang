/* eslint-disable @typescript-eslint/no-explicit-any */
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

// Custom service worker with comprehensive caching
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute, setCatchHandler } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Properly type self as ServiceWorkerGlobalScope
declare const self: ServiceWorkerGlobalScope;

// Disable dev logs in production
if (typeof self !== 'undefined') {
  self.__WB_DISABLE_DEV_LOGS = true;
}

// Handle SKIP_WAITING message - THIS IS CRITICAL FOR UPDATE FUNCTIONALITY
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[SW] Received SKIP_WAITING message, activating new version');
    self.skipWaiting().then(() => {
      // After skip waiting, notify all clients
      self.clients.matchAll().then(clients => {
        clients.forEach(client => {
          client.postMessage({
            type: 'SW_UPDATED',
            message: 'Service worker updated successfully'
          });
        });
      });
    });
  }
});

// Precache all the assets generated by next-pwa (essential pages)
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches
cleanupOutdatedCaches();

// Allow service worker to claim clients immediately
clientsClaim();

// ============================================
// 1. CACHE STATIC RESOURCES (CSS, JS, Images, Fonts)
// ============================================
// CacheFirst strategy - assets don't change often
registerRoute(
  /^\/(_next\/static|static)\/.*/i,
  new CacheFirst({
    cacheName: 'static-resources-v2',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        purgeOnQuotaError: true,
      }),
    ],
  }),
  'GET'
);

// Cache images automatically as they load
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-v2',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  }),
  'GET'
);

// Cache fonts automatically
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-v2',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  }),
  'GET'
);

// Cache CSS and JS files
registerRoute(
  ({ request }) => request.destination === 'style' || request.destination === 'script',
  new CacheFirst({
    cacheName: 'styles-scripts-v2',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  }),
  'GET'
);

// ============================================
// 2. CACHE API RESPONSES
// ============================================
registerRoute(
  /\/api\/.*/,
  new NetworkFirst({
    cacheName: 'api-cache-v2',
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  }),
  'GET'
);

// ============================================
// 3. AUTO-CACHE ALL NAVIGATION REQUESTS (Pages user visits)
// ============================================
// This automatically caches EVERY page the user visits
// Using NetworkFirst with 1s timeout for faster offline response
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'visited-pages-v2',
    networkTimeoutSeconds: 1, // Reduced timeout for faster offline response
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200, // Increased to cache more visited pages
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  }),
  'GET'
);

// Cache all HTML/document requests (pages)
registerRoute(
  ({ request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'visited-pages-v2',
    networkTimeoutSeconds: 1, // Reduced timeout for faster offline response
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  }),
  'GET'
);

// Cache admin and manager pages specifically
registerRoute(
  /^\/(en|ar|fr)\/(manager|admin)\/.*/,
  new NetworkFirst({
    cacheName: 'dashboard-pages-v2',
    networkTimeoutSeconds: 1, // Reduced timeout for faster offline response
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 150,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
        purgeOnQuotaError: true,
      }),
    ],
  }),
  'GET'
);

// ============================================
// 4. FALLBACK TO OFFLINE PAGE (Global Catch Handler)
// ============================================
// If network fails and cache doesn't have it, serve offline page
setCatchHandler(async ({ event }: any) => {
  const { request } = event;
  
  // Only handle navigation/document requests
  if (request.mode === 'navigate' || request.destination === 'document') {
    // Try to get from any cache first
    const cachedResponse = await caches.match(request, {
      ignoreSearch: true,
      ignoreMethod: true,
      ignoreVary: true,
    });
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // Fallback to offline page
    const offlinePage = await caches.match('/offline.html');
    if (offlinePage) {
      return offlinePage;
    }
    
    // Last resort: return a simple HTML response
    return new Response(
      `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>Offline</title>
          <style>
            body { 
              font-family: system-ui, sans-serif; 
              display: flex; 
              align-items: center; 
              justify-content: center; 
              height: 100vh; 
              margin: 0;
              background: #f5f5f5;
            }
            .container {
              text-align: center;
              padding: 2rem;
              background: white;
              border-radius: 8px;
              box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            h1 { color: #666; margin-bottom: 1rem; }
            p { color: #888; }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>You're Offline</h1>
            <p>Please check your internet connection and try again.</p>
          </div>
        </body>
      </html>
      `,
      {
        headers: { 'Content-Type': 'text/html' },
        status: 200,
        statusText: 'OK',
      }
    );
  }
  
  // For non-navigation requests, return error
  return Response.error();
});

// ============================================
// 5. INSTALL EVENT - Precache Essential Pages
// ============================================
self.addEventListener('install', (event: any) => {
  console.log('[SW] Service worker installing...');
  
  event.waitUntil(
    (async () => {
      // Open cache for offline page
      const offlineCache = await caches.open('offline-pages-v2');
      
      // Precache offline page immediately
      try {
        await offlineCache.add('/offline.html');
        console.log('[SW] Offline page precached');
      } catch (error) {
        console.warn('[SW] Failed to precache offline page:', error);
      }
      
      // Precache essential static assets
      const staticCache = await caches.open('static-resources-v2');
      const essentialAssets = [
        '/manifest.json',
        '/icon-192x192.png',
        '/icon-512x512.png',
      ];
      
      try {
        await Promise.all(
          essentialAssets.map(url => 
            staticCache.add(url).catch(err => 
              console.warn(`[SW] Failed to cache ${url}:`, err)
            )
          )
        );
        console.log('[SW] Essential assets precached');
      } catch (error) {
        console.warn('[SW] Failed to precache some assets:', error);
      }
      
      // Skip waiting to activate immediately
      return self.skipWaiting();
    })()
  );
});

// ============================================
// 6. ACTIVATE EVENT - Clean up old caches
// ============================================
self.addEventListener('activate', (event: any) => {
  console.log('[SW] Service worker activating...');
  
  event.waitUntil(
    (async () => {
      // Clean up old cache versions
      const cacheNames = await caches.keys();
      const oldCaches = cacheNames.filter(name => 
        name.startsWith('static-resources') && name !== 'static-resources-v2' ||
        name.startsWith('pages') && name !== 'visited-pages-v2' && name !== 'dashboard-pages-v2' ||
        name.startsWith('api-cache') && name !== 'api-cache-v2' ||
        name.startsWith('offline-pages') && name !== 'offline-pages-v2' ||
        name.startsWith('images') && name !== 'images-v2' ||
        name.startsWith('fonts') && name !== 'fonts-v2' ||
        name.startsWith('styles-scripts') && name !== 'styles-scripts-v2'
      );
      
      await Promise.all(
        oldCaches.map(name => {
          console.log(`[SW] Deleting old cache: ${name}`);
          return caches.delete(name);
        })
      );
      
      // Take control of all clients immediately
      return self.clients.claim();
    })()
  );
});

// Export to make this a module
export { };

